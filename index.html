<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KryoCoin Dashboard</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Helvetica', 'Arial', sans-serif; min-height: 100vh; display: flex; flex-direction: column; background: #000000; overflow: auto; }
        #page, #main, .site-main, .content-area { margin-left: 0 !important; padding-left: 0 !important; float: none !important; width: 100% !important; display: flex; justify-content: center; flex: 1; }
        canvas#particleCanvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; pointer-events: none; }
        

    .container { 
        width: 95vw; 
        max-width: 1200px; 
        margin: 2vh auto; 
        background: #1C252E; 
        border-radius: 8px; 
        box-shadow: 0 0 20px rgba(29, 161, 242, 0.5); 
        color: #FFFFFF; 
        z-index: 1; 
        animation: fadeIn 0.5s ease-in-out; 
        display: flex; 
        flex-direction: column; 
        padding: 2vw; 
        gap: 2vh; 
        min-height: 96vh; 
        position: relative; 
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

    .hud { 
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        background: rgba(28, 37, 46, 0.9); 
        padding: 1vh 2vw; 
        display: flex; 
        align-items: center; 
        gap: 1vw; 
        z-index: 2; 
        border-bottom: 1px solid #38444D; 
        font-family: 'Courier New', monospace; 
        font-size: clamp(0.8rem, 1.2vw, 1rem); 
        color: #FFFFFF; 
    }
    .hud i.material-icons { color: #1DA1F2; }
    .hud span { margin-right: 2vw; }

    .header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        padding: 2vh 0; 
        margin-top: 6vh; 
    }
    .left-buttons { display: flex; gap: 1vw; }
    .social-links { display: flex; gap: 1vw; }
    .social-links a, .left-buttons a { 
        padding: 1vh; 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        color: #FFFFFF; 
        transition: background 0.3s, transform 0.2s; 
        display: flex; 
        align-items: center; 
    }
    .social-links a:hover, .left-buttons a:hover { background: #1DA1F2; transform: scale(1.05); }
    
    .onboarding, .dashboard, .readme { 
        display: none; 
        flex-direction: column; 
        gap: 2vh; 
        flex: 1; 
    }
    .onboarding.visible, .dashboard.visible, .readme.visible { display: flex; }
    
    .sidebar { 
        width: 20vw; 
        min-width: 180px; 
        background: #192734; 
        padding: 2vw; 
        display: flex; 
        flex-direction: column; 
        gap: 1.5vh; 
        border-right: 1px solid #38444D; 
        height: 100%; 
    }
    .sidebar h2 { 
        font-size: clamp(1.2rem, 2.5vw, 1.5rem); 
        margin-bottom: 2vh; 
        text-align: center; 
        text-shadow: 0 0 5px rgba(29, 161, 242, 0.5); 
    }
    .sidebar button { 
        padding: 1vh 1vw; 
        font-size: clamp(0.9rem, 1.5vw, 1rem); 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        color: #FFFFFF; 
        border-radius: 6px; 
        cursor: pointer; 
        transition: background 0.3s, transform 0.2s; 
        display: flex; 
        align-items: center; 
        gap: 1vw; 
    }
    .sidebar button:hover { background: #1DA1F2; transform: scale(1.05); }
    .sidebar button.active { background: #1DA1F2; box-shadow: 0 0 10px rgba(29, 161, 242, 0.8); }
    
    .content-area { flex: 1; display: flex; flex-direction: row; height: 100%; }
    .content { 
        flex: 1; 
        padding: 2vw; 
        display: none; 
        flex-direction: column; 
        gap: 2vh; 
        overflow-y: auto; 
    }
    .content.visible { display: flex; }
    
    h3 { 
        font-size: clamp(1.2rem, 2.5vw, 1.5rem); 
        text-align: center; 
        text-shadow: 0 0 5px rgba(29, 161, 242, 0.5); 
    }
    .input-group { 
        display: flex; 
        align-items: center; 
        gap: 1vw; 
        position: relative; 
        width: 100%; 
    }
    input, textarea { 
        flex: 1; 
        padding: 1vh 1vw 1vh 5vw; 
        font-size: clamp(0.9rem, 1.5vw, 1rem); 
        border: 1px solid #38444D; 
        background: #2C2F33; 
        color: #FFFFFF; 
        border-radius: 6px; 
        transition: border-color 0.3s; 
        font-family: 'Courier New', monospace; 
    }
    input:focus, textarea:focus { border-color: #1DA1F2; outline: none; }
    .input-group .material-icons { color: #FFFFFF; }
    .input-group .prefix-icon { position: absolute; left: 1vw; top: 50%; transform: translateY(-50%); }
    .input-group .copy-icon { position: absolute; left: 3vw; top: 50%; transform: translateY(-50%); cursor: pointer; transition: color 0.3s; }
    .input-group .paste-icon { cursor: pointer; transition: color 0.3s; }
    .copy-icon:hover, .paste-icon:hover { color: #1DA1F2; }
    
    button { 
        padding: 1vh 2vw; 
        font-size: clamp(0.9rem, 1.5vw, 1rem); 
        background: #192734; 
        border: 1px solid #38444D; 
        color: #FFFFFF; 
        cursor: pointer; 
        border-radius: 6px; 
        transition: background 0.3s, transform 0.2s; 
        display: flex; 
        align-items: center; 
        gap: 0.5vw; 
        font-family: 'Courier New', monospace; 
    }
    button:hover { background: #1DA1F2; transform: scale(1.05); }
    .button-group { display: flex; justify-content: center; gap: 1.5vw; flex-wrap: wrap; margin-top: 1.5vh; }
    
    .log { 
        border: 1px solid #38444D; 
        height: 15vh; 
        min-height: 100px; 
        overflow-y: auto; 
        padding: 1vh; 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        background: #2C2F33; 
        color: #8899A6; 
        border-radius: 6px; 
        font-family: 'Courier New', monospace; 
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5); 
    }
    #status { 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        padding: 1vh; 
        text-align: left; 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        font-family: 'Courier New', monospace; 
        position: absolute; 
        bottom: 1vh; 
        left: 1vw; 
    }
    .instructions { 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        padding: 1vh; 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        text-align: center; 
        font-family: 'Courier New', monospace; 
    }
    .key-display { 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        padding: 1vh; 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        display: flex; 
        align-items: center; 
        gap: 1vw; 
        position: relative; 
        width: 100%; 
        font-family: 'Courier New', monospace; 
    }
    .key-display .material-icons { position: absolute; left: 1vw; top: 50%; transform: translateY(-50%); color: #FFFFFF; }
    .key-display span { flex: 1; padding: 0 4vw; word-wrap: break-word; overflow-wrap: break-word; white-space: normal; color: #FFFFFF; }
    .key-display button { padding: 1vh; }
    
    #walletInfo, #fractalStakeInfo { 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        padding: 1vh; 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        text-align: center; 
        font-family: 'Courier New', monospace; 
        margin: 0.5vh 0; 
        word-wrap: break-word; 
    }
    #burnDialog { 
        display: none; 
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        background: #1C252E; 
        border: 2px solid #FF3333; 
        padding: 1.5vh; 
        color: #FF3333; 
        border-radius: 6px; 
        z-index: 10; 
        box-shadow: 0 0 15px rgba(255, 51, 51, 0.5); 
        font-family: 'Courier New', monospace; 
        width: 90vw; 
        max-width: 400px; 
    }
    #burnDialog input { border-color: #FF3333; background: #2C2F33; color: #FFFFFF; }
    #burnDialog button { background: #FF3333; color: #FFFFFF; border: none; }
    #burnDialog button:hover { background: #FF5555; transform: scale(1.05); }
    
    #chatLog { height: 30vh; overflow-y: auto; }
    #chatLog div { word-wrap: break-word; overflow-wrap: break-word; white-space: normal; }
    #chatLog .sender { font-weight: bold; }
    #chatInput { padding: 1vh; resize: none; }
    
    .color-picker, .username-picker { display: flex; align-items: center; gap: 0.5vw; margin-top: 1vh; }
    .color-picker label, .username-picker label { font-size: clamp(0.8rem, 1.2vw, 0.9rem); color: #FFFFFF; }
    .color-picker input[type="color"] { width: 40px; height: 40px; border: none; background: none; cursor: pointer; }
    .username-picker input[type="text"] { padding: 0.5vh 1vw; font-size: clamp(0.8rem, 1.2vw, 0.9rem); width: 150px; }
    
    .readme-content { 
        padding: 2vw; 
        font-size: clamp(0.9rem, 1.5vw, 1rem); 
        background: #2C2F33; 
        border: 1px solid #38444D; 
        border-radius: 6px; 
        font-family: 'Courier New', monospace; 
        overflow-y: auto; 
        flex: 1; 
    }
    .footer { 
        font-size: clamp(0.8rem, 1.2vw, 0.9rem); 
        padding: 1vh; 
        text-align: center; 
        background: #192734; 
        border-top: 1px solid #38444D; 
        border-radius: 0 0 8px 8px; 
        color: #8899A6; 
        font-family: 'Courier New', monospace; 
    }
    
    @media (max-width: 768px) { 
        .content-area { flex-direction: column; } 
        .sidebar { width: 100%; border-right: none; border-bottom: 1px solid #38444D; padding: 2vh; } 
        .sidebar button { justify-content: center; } 
        .container { padding: 3vw; } 
        .header { flex-direction: column; gap: 1vh; } 
        .left-buttons, .social-links { justify-content: center; width: 100%; } 
        .hud { flex-direction: column; align-items: flex-start; padding: 1vh; }
    }
    @media (max-width: 480px) { 
        .input-group { flex-direction: column; align-items: stretch; } 
        .input-group .paste-icon { position: static; transform: none; margin: 1vh auto; } 
        .button-group { flex-direction: column; gap: 1vh; } 
        .sidebar { min-width: 100%; } 
        .social-links { flex-wrap: wrap; } 
        .username-picker input[type="text"] { width: 100%; } 
        .hud { font-size: 0.7rem; }
    }
</style>

</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="hud">
        <i class="material-icons">bar_chart</i>
        <span>Balance: <span id="hudBalance">0.0000</span> KRY</span>
        <span>Stake: <span id="hudFractalStake">0.0000</span> KRY</span>
        <span>Mining Rate: <span id="hudMiningRate">0.0001 KRY/block</span></span>
        <span>Height: <span id="hudHeight">0</span></span>
        <span>Peers: <span id="hudPeerCount">0</span></span>
    </div>
    <div class="container">
        <div class="header">
            <div class="left-buttons">
                <button id="logoutBtn"><i class="material-icons">exit_to_app</i></button>
                <button id="dashboardBtn"><i class="material-icons">dashboard</i></button>
                <button id="infoBtn"><i class="material-icons">info</i></button>
                <a href="#" id="researchPaper"><i class="material-icons">description</i></a>
            </div>
            <div class="social-links">
                <a href="https://facebook.com" target="_blank"><i class="material-icons">facebook</i></a>
                <a href="https://github.com" target="_blank"><i class="material-icons">code</i></a>
                <a href="https://x.com" target="_blank"><i class="material-icons">public</i></a>
                <a href="https://instagram.com" target="_blank"><i class="material-icons">photo_camera</i></a>
                <a href="https://youtube.com" target="_blank"><i class="material-icons">play_circle</i></a>
            </div>
        </div>
        <div class="onboarding visible" id="onboarding">
            <h3>KryoCoin Dashboard</h3>
            <div class="instructions">Check wallet status
Connect to network
Start mining</div>
            <div class="input-group">
                <i class="material-icons prefix-icon">key</i>
                <i class="material-icons copy-icon" id="copyWalletIdIcon">content_copy</i>
                <input type="text" id="walletId" placeholder="Enter your Wallet Key HERE...">
                <i class="material-icons paste-icon" id="pasteWalletIdIcon">content_paste</i>
            </div>
            <div class="input-group">
                <i class="material-icons prefix-icon">lock</i>
                <i class="material-icons copy-icon" id="copyPassphraseIcon" style="display:none;">content_copy</i>
                <input type="password" id="passphrase" placeholder="Passphrase (8+ chars)">
                <i class="material-icons paste-icon" id="pastePassphraseIcon">content_paste</i>
            </div>
            <div class="button-group">
                <button id="loginBtn"><i class="material-icons">lock_open</i>Login</button>
                <button id="createWalletBtn"><i class="material-icons">add</i>Create Wallet</button>
            </div>
            <div class="key-display">
                <i class="material-icons">key</i>
                <span id="pubKeyDisplay">Your Public Key: Not set</span>
                <button id="copyPubKeyBtn"><i class="material-icons">content_copy</i>Copy</button>
            </div>
        </div>
        <div class="dashboard" id="dashboard">
            <div class="content-area">
                <div class="sidebar">
                    <h2>KryoCoin Dashboard</h2>
                    <button id="sendReceiveBtn" class="active"><i class="material-icons">swap_horiz</i>Send/Receive</button>
                    <button id="mineBtn"><i class="material-icons">gavel</i>Mine</button>
                    <button id="stakingBtn"><i class="material-icons">link</i>Staking</button>
                    <button id="chatBtn"><i class="material-icons">chat</i>Chat</button>
                </div>
                <div id="sendReceiveScreen" class="content visible">
                    <h3>Send/Receive</h3>
                    <div id="walletInfo">Wallet: <span id="walletAddress">Not set</span></div>
                    <div class="input-group">
                        <i class="material-icons prefix-icon">person</i>
                        <i class="material-icons copy-icon" id="copyRecipientIcon">content_copy</i>
                        <input type="text" id="recipient" placeholder="Recipient Pubkey">
                        <i class="material-icons paste-icon" id="pasteRecipientIcon">content_paste</i>
                    </div>
                    <div class="input-group">
                        <i class="material-icons prefix-icon">monetization_on</i>
                        <i class="material-icons copy-icon" id="copyAmountIcon" style="display:none;">content_copy</i>
                        <input type="number" id="amount" placeholder="Amount (KRY)" min="0" step="0.001">
                        <i class="material-icons paste-icon" id="pasteAmountIcon">content_paste</i>
                    </div>
                    <div class="button-group">
                        <button id="sendTxBtn"><i class="material-icons">send</i>Send</button>
                    </div>
                    <div class="log" id="log">Events:</div>
                </div>
                <div id="mineScreen" class="content">
                    <h3>Mine</h3>
                    <div id="walletInfo">Wallet: <span id="mineWalletAddress">Not set</span></div>
                    <div class="button-group">
                        <button id="startMiningBtn"><i class="material-icons">gavel</i>Start Mining</button>
                    </div>
                    <div class="log" id="mineLog">Events:</div>
                </div>
                <div id="stakingScreen" class="content">
                    <h3>Staking</h3>
                    <div id="fractalStakeInfo">Stake Details: <span id="stakeDetails">KryoCases Frozen: 0 | Unfroze: 0</span></div>
                    <div class="input-group">
                        <i class="material-icons prefix-icon">trending_up</i>
                        <i class="material-icons copy-icon" id="copyStakeAmountIcon" style="display:none;">content_copy</i>
                        <input type="number" id="stakeAmount" placeholder="Stake Amount (KRY)" min="0" step="0.001">
                        <i class="material-icons paste-icon" id="pasteStakeAmountIcon">content_paste</i>
                    </div>
                    <div class="button-group">
                        <button id="stakeBtn"><i class="material-icons">link</i>Stake</button>
                        <button id="thawBtn"><i class="material-icons">lock_open</i>Thaw (0)</button>
                        <button id="burnBtn"><i class="material-icons">local_fire_department</i>Burn</button>
                    </div>
                    <div class="log" id="stakeLog">Events:</div>
                </div>
                <div id="chatScreen" class="content">
                    <h3>Chat</h3>
                    <div class="log" id="chatLog">Chat Messages:</div>
                    <div class="input-group">
                        <i class="material-icons prefix-icon">message</i>
                        <textarea id="chatInput" placeholder="Type a message..." rows="2"></textarea>
                    </div>
                    <div class="username-picker">
                        <label for="chatUsername">Username:</label>
                        <input type="text" id="chatUsername" placeholder="Set your username" maxlength="20">
                    </div>
                    <div class="color-picker">
                        <label for="chatColor">Chat Color:</label>
                        <input type="color" id="chatColor" value="#FFFFFF">
                    </div>
                    <div class="button-group">
                        <button id="sendChatBtn"><i class="material-icons">send</i>Send</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="readme" id="readme">
            <h3>README</h3>
            <div class="readme-content">
                <strong>Welcome to KryoCoin Dashboard</strong>

                KryoCoin (KRY) is a decentralized cryptocurrency platform. This dashboard lets you:

                - Create or log into a wallet

                - Send and receive KRY

                - Mine blocks for rewards

                - Stake KRY with our Fractal Staking system

                - Chat with peers

                <strong>How to Start:</strong>

                1. Enter a Wallet ID and passphrase (8+ chars) to log in, or create a new wallet.

                2. Connect to the network and explore the features.

                3. Back up your Wallet ID and passphrase—there’s no recovery if lost.

                <strong>Notice:</strong>

                This is an early version of KryoCoin. Bugs may occur, but they’ll be fixed in future updates. Thanks for trying it out!

                <em>KryoCoin v1.0 | 'FTL' Architecture | © 2025</em>
            </div>
        </div>
        <div id="status">[SYS] Initializing...</div>
        <div id="burnDialog">
            <h3>Burn KRY</h3>
            <div class="input-group">
                <i class="material-icons prefix-icon">local_fire_department</i>
                <i class="material-icons copy-icon" id="copyBurnAmountIcon" style="display:none;">content_copy</i>
                <input type="number" id="burnAmount" placeholder="Amount to Burn (KRY)" min="0" step="0.001">
                <i class="material-icons paste-icon" id="pasteBurnAmountIcon">content_paste</i>
            </div>
            <div class="button-group">
                <button id="confirmBurnBtn"><i class="material-icons">check</i>Confirm</button>
                <button id="cancelBurnBtn"><i class="material-icons">close</i>Cancel</button>
            </div>
        </div>
        <div class="footer">KryoCoin v1.0 | 'FTL' Architecture | © 2025</div>
    </div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
<script>
    const dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open('KryoCoinDB', 2);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = event => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('wallet')) {
                db.createObjectStore('wallet', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('blockchain')) {
                db.createObjectStore('blockchain', { keyPath: 'id' });
            }
        };
    });
async function setItem(storeName, id, value) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        const store = tx.objectStore(storeName);
        store.put({ id, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function getItem(storeName, id) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readonly');
        const store = tx.objectStore(storeName);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result?.value);
        request.onerror = () => reject(request.error);
    });
}

const canvas = document.getElementById('particleCanvas');
const ctx = canvas.getContext('2d');
let particlesArray = [];

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class BackgroundParticle {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 1;
        this.speedX = Math.random() * 1 - 0.5;
        this.speedY = Math.random() * 1 - 0.5;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        if (this.size > 0.2) this.size -= 0.01;
        if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
        if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
    }
    draw() {
        ctx.fillStyle = 'rgba(29, 161, 242, 0.5)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function initParticles() {
    particlesArray = [];
    for (let i = 0; i < 100; i++) {
        particlesArray.push(new BackgroundParticle());
    }
}
initParticles();

function animateAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < particlesArray.length; i++) {
        particlesArray[i].update();
        particlesArray[i].draw();
        if (particlesArray[i].size <= 0.2) {
            particlesArray.splice(i, 1);
            i--;
            particlesArray.push(new BackgroundParticle());
        }
    }
    requestAnimationFrame(animateAll);
}
animateAll();

class CryptoWallet {
    constructor() {
        this.ec = new elliptic.ec('secp256k1');
        this.keyPair = null;
        this.pubKey = null;
        this.chatColor = '#FFFFFF';
        this.chatUsername = 'Anonymous';
        this.peers = {};
        this.connectedPeers = new Set();
        this.messageHistory = new Set();
        this.lastAttempt = {};
        this.MAX_PEERS = 20;
        this.ATTEMPT_COOLDOWN = 5000;
        this.BROADCAST_INTERVAL = 1000;
        this.SYNC_INTERVAL = 2000;
        this.onboardingChannel = new BroadcastChannel('kryocoin-onboarding');
        this.networkChannel = null;
        this.blockchain = new Blockchain(this);
        this.currentScreen = 'sendReceive';
        this.initialize();
        this.bindEvents();
        this.startPeerDiscovery();
    }

    async initialize() {
        if (!window.isSecureContext) {
            document.body.innerHTML = "<div>Requires HTTPS or localhost</div>";
            return;
        }
        this.updateStatus("[SYS] Set up wallet");
        if (!window.RTCPeerConnection) {
            this.updateStatus("[ERR] WebRTC not supported");
        }
        setInterval(() => this.blockchain.syncWithPeers(), this.SYNC_INTERVAL);
    }

    bindEvents() {
        document.getElementById('loginBtn').addEventListener('click', () => this.login());
        document.getElementById('createWalletBtn').addEventListener('click', () => this.createWallet());
        document.getElementById('sendReceiveBtn').addEventListener('click', () => this.showScreen('sendReceive'));
        document.getElementById('mineBtn').addEventListener('click', () => this.showScreen('mine'));
        document.getElementById('stakingBtn').addEventListener('click', () => this.showScreen('staking'));
        document.getElementById('chatBtn').addEventListener('click', () => this.showScreen('chat'));
        document.getElementById('sendTxBtn').addEventListener('click', () => this.sendTx());
        document.getElementById('startMiningBtn').addEventListener('click', () => this.blockchain.startMining());
        document.getElementById('stakeBtn').addEventListener('click', () => this.stakeFractal());
        document.getElementById('thawBtn').addEventListener('click', () => this.thawFractal());
        document.getElementById('burnBtn').addEventListener('click', () => this.showBurnDialog());
        document.getElementById('confirmBurnBtn').addEventListener('click', () => this.burnKRY());
        document.getElementById('cancelBurnBtn').addEventListener('click', () => this.hideBurnDialog());
        document.getElementById('sendChatBtn').addEventListener('click', () => this.sendChatMessage());
        document.getElementById('logoutBtn').addEventListener('click', () => this.logout());
        document.getElementById('dashboardBtn').addEventListener('click', () => this.showDashboard());
        document.getElementById('infoBtn').addEventListener('click', () => this.toggleReadme());
        document.getElementById('copyWalletIdIcon').addEventListener('click', () => this.copyText(document.getElementById('walletId').value, "Wallet ID"));
        document.getElementById('pasteWalletIdIcon').addEventListener('click', () => this.pasteText('walletId', "Wallet ID"));
        document.getElementById('copyPubKeyBtn').addEventListener('click', () => this.copyText(this.pubKey, "Public key"));
        document.getElementById('copyRecipientIcon').addEventListener('click', () => this.copyText(document.getElementById('recipient').value, "Recipient Pubkey"));
        document.getElementById('pasteRecipientIcon').addEventListener('click', () => this.pasteText('recipient', "Recipient Pubkey"));
    }

    showScreen(screen) {
        const screens = ['sendReceive', 'mine', 'staking', 'chat'];
        screens.forEach(s => {
            const element = document.getElementById(`${s}Screen`);
            const button = document.getElementById(`${s}Btn`);
            if (s === screen) {
                element.classList.add('visible');
                button.classList.add('active');
            } else {
                element.classList.remove('visible');
                button.classList.remove('active');
            }
        });
        this.currentScreen = screen;
        this.blockchain.updateUI();
    }

    async sha256(str) {
        const buffer = new TextEncoder().encode(str);
        const hash = await crypto.subtle.digest('SHA-256', buffer);
        return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async deriveKey(passphrase) {
        return CryptoJS.PBKDF2(passphrase, "salt", { keySize: 256 / 32, iterations: 500 }).toString(CryptoJS.enc.Hex);
    }

    async login() {
        try {
            const walletId = document.getElementById("walletId").value.trim();
            const passphrase = document.getElementById("passphrase").value;
            if (!walletId || passphrase.length < 8) throw new Error("Invalid credentials");
            const storedKey = await getItem('wallet', `key_${walletId}`);
            if (!storedKey) throw new Error("Wallet not found");
            const encryptionKey = await this.deriveKey(passphrase);
            const decryptedKey = CryptoJS.AES.decrypt(storedKey, encryptionKey).toString(CryptoJS.enc.Utf8);
            this.keyPair = this.ec.keyFromPrivate(decryptedKey, 'hex');
            if (this.keyPair.getPublic('hex') !== walletId) throw new Error("Invalid passphrase");
            this.pubKey = walletId;
            await this.blockchain.loadChain();
            this.joinMainNetwork();
            this.updatePubKeyDisplay();
            document.getElementById('onboarding').classList.remove('visible');
            document.getElementById('dashboard').classList.add('visible');
            this.showScreen('sendReceive');
            this.updateStatus(`[SYS] Logged in. Connecting to network...`);
        } catch (e) {
            this.updateStatus(`[ERR] Login failed: ${e.message}`);
        }
    }

    async createWallet() {
        try {
            const passphrase = document.getElementById("passphrase").value;
            if (passphrase.length < 8) throw new Error("Passphrase too short");
            this.keyPair = this.ec.genKeyPair();
            this.pubKey = this.keyPair.getPublic('hex');
            const encryptionKey = await this.deriveKey(passphrase);
            const encryptedKey = CryptoJS.AES.encrypt(this.keyPair.getPrivate('hex'), encryptionKey).toString();
            await setItem('wallet', `key_${this.pubKey}`, encryptedKey);
            this.blockchain.initializeWallet();
            await this.blockchain.saveState();
            this.joinMainNetwork();
            document.getElementById("walletId").value = this.pubKey;
            this.updatePubKeyDisplay();
            document.getElementById('onboarding').classList.remove('visible');
            document.getElementById('dashboard').classList.add('visible');
            this.showScreen('sendReceive');
            this.updateStatus(`[SYS] Wallet created. Connecting to network...`);
        } catch (e) {
            this.updateStatus(`[ERR] Creation failed: ${e.message}`);
        }
    }

    logout() {
        this.keyPair = null;
        this.pubKey = null;
        this.peers = {};
        this.connectedPeers.clear();
        if (this.networkChannel) this.networkChannel.close();
        this.networkChannel = null;
        this.onboardingChannel = new BroadcastChannel('kryocoin-onboarding');
        document.getElementById('dashboard').classList.remove('visible');
        document.getElementById('readme').classList.remove('visible');
        document.getElementById('onboarding').classList.add('visible');
        this.updateStatus('[SYS] Logged out');
        this.blockchain.updateUI();
    }

    showDashboard() {
        document.getElementById('readme').classList.remove('visible');
        document.getElementById('dashboard').classList.add('visible');
        this.showScreen('sendReceive');
    }

    toggleReadme() {
        const readme = document.getElementById('readme');
        const dashboard = document.getElementById('dashboard');
        const onboarding = document.getElementById('onboarding');
        if (readme.classList.contains('visible')) {
            readme.classList.remove('visible');
            if (this.pubKey) dashboard.classList.add('visible');
            else onboarding.classList.add('visible');
        } else {
            readme.classList.add('visible');
            dashboard.classList.remove('visible');
            onboarding.classList.remove('visible');
        }
    }

    copyText(text, label) {
        if (!text) {
            this.updateStatus(`[ERR] No ${label.toLowerCase()} to copy`);
            return;
        }
        navigator.clipboard.writeText(text)
            .then(() => this.updateStatus(`[SYS] ${label} copied`))
            .catch(e => this.updateStatus(`[ERR] Copy failed: ${e.message}`));
    }

    async pasteText(elementId, label) {
        try {
            const text = await navigator.clipboard.readText();
            document.getElementById(elementId).value = text;
            this.updateStatus(`[SYS] ${label} pasted`);
        } catch (e) {
            this.updateStatus(`[ERR] Paste failed: ${e.message}`);
        }
    }

    createPeerConnection(peerId, isInitiator = false) {
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        const channel = pc.createDataChannel(`kryocoin-${peerId.slice(0, 8)}`);
        pc.onicecandidate = event => event.candidate && this.networkChannel.postMessage({
            type: 'candidate',
            candidate: event.candidate.toJSON(),
            from: this.pubKey,
            to: peerId
        });
        pc.ondatachannel = event => this.setupDataChannel(event.channel, peerId);
        pc.onconnectionstatechange = () => {
            if (pc.connectionState === 'connected') {
                this.connectedPeers.add(peerId);
                this.peers[peerId] = { pc, channel };
                this.updateStatus(`[SYS] Connected to ${peerId.slice(0, 8)}`);
                this.blockchain.requestStateSync(channel);
                this.blockchain.updateUI();
            }
        };
        if (isInitiator) {
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => this.networkChannel.postMessage({
                    type: 'offer',
                    offer: { type: pc.localDescription.type, sdp: pc.localDescription.sdp },
                    from: this.pubKey,
                    to: peerId
                }));
        }
        this.peers[peerId] = { pc, channel };
        this.setupDataChannel(channel, peerId);
        return pc;
    }

    setupDataChannel(channel, peerId) {
        channel.onopen = () => {
            this.peers[peerId].channel = channel;
            this.blockchain.requestStateSync(channel);
        };
        channel.onmessage = event => this.onMessage(event.data, peerId);
    }

    attemptConnection(peerId, isInitiator = true) {
        if (this.connectedPeers.size >= this.MAX_PEERS || this.peers[peerId] || peerId === this.pubKey) return;
        const now = Date.now();
        if (this.lastAttempt[peerId] && now - this.lastAttempt[peerId] < this.ATTEMPT_COOLDOWN) return;
        this.lastAttempt[peerId] = now;
        this.createPeerConnection(peerId, isInitiator);
    }

    joinMainNetwork() {
        if (this.networkChannel) return;
        this.onboardingChannel.close();
        this.networkChannel = new BroadcastChannel('kryocoin-network');
        this.networkChannel.onmessage = async event => {
            const { type, from, to, offer, answer, candidate } = event.data;
            if (from === this.pubKey) return;
            if (type === 'announce') this.attemptConnection(from);
            else if (type === 'offer' && to === this.pubKey) {
                const pc = this.createPeerConnection(from, false);
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                this.networkChannel.postMessage({
                    type: 'answer',
                    answer: { type: answer.type, sdp: answer.sdp },
                    from: this.pubKey,
                    to: from
                });
            } else if (type === 'answer' && to === this.pubKey) {
                await this.peers[from].pc.setRemoteDescription(new RTCSessionDescription(answer));
            } else if (type === 'candidate' && to === this.pubKey && this.peers[from]) {
                await this.peers[from].pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        };
    }

    startPeerDiscovery() {
        setInterval(() => {
            if (this.networkChannel && this.pubKey) {
                this.networkChannel.postMessage({ type: 'announce', from: this.pubKey });
            }
        }, this.BROADCAST_INTERVAL);
    }

    async onMessage(data, fromPeerPubkey) {
        const msg = JSON.parse(data);
        if (msg.pubKey === this.pubKey) return;
        switch (msg.type) {
            case 'transaction':
                this.updateStatus(`[SYS] Received transaction from ${fromPeerPubkey.slice(0, 8)}`);
                await this.blockchain.receiveTransaction(msg.data);
                this.relayMessage(msg, fromPeerPubkey);
                break;
            case 'block':
                this.updateStatus(`[SYS] Received block from ${fromPeerPubkey.slice(0, 8)}`);
                await this.blockchain.receiveBlock(msg.data, fromPeerPubkey);
                this.relayMessage(msg, fromPeerPubkey);
                break;
            case 'state_request':
                this.updateStatus(`[SYS] State requested by ${fromPeerPubkey.slice(0, 8)}`);
                if (this.peers[fromPeerPubkey]?.channel?.readyState === 'open') {
                    this.peers[fromPeerPubkey].channel.send(JSON.stringify({
                        type: 'state',
                        data: {
                            chain: [this.blockchain.longestChain.block],
                            utxos: this.blockchain.longestChain.utxos,
                            fractalStakes: this.blockchain.longestChain.fractalStakes,
                            stats: this.blockchain.longestChain.stats
                        },
                        pubKey: this.pubKey
                    }));
                }
                break;
            case 'state':
                this.updateStatus(`[SYS] Received state from ${fromPeerPubkey.slice(0, 8)}`);
                await this.blockchain.syncState(msg.data);
                break;
            case 'chat':
                if (!this.messageHistory.has(msg.data.messageId)) {
                    this.updateStatus(`[SYS] Received chat from ${fromPeerPubkey.slice(0, 8)}`);
                    this.displayChatMessage(msg.data, fromPeerPubkey);
                    this.relayMessage(msg, fromPeerPubkey);
                }
                break;
        }
    }

    relayMessage(data, senderPeerId) {
        Object.keys(this.peers).forEach(peerId => {
            if (peerId !== senderPeerId && peerId !== this.pubKey) {
                const channel = this.peers[peerId].channel;
                if (channel?.readyState === 'open') {
                    channel.send(JSON.stringify(data));
                }
            }
        });
    }

    broadcast(message) {
        const msg = JSON.stringify({ ...message, pubKey: this.pubKey });
        Object.values(this.peers).forEach(({ channel }) => {
            if (channel?.readyState === 'open') {
                channel.send(msg);
            }
        });
    }

    async sendTx() {
        try {
            const recipient = document.getElementById("recipient").value.trim();
            const amount = parseFloat(document.getElementById("amount").value) || 0;
            if (!recipient || amount <= 0) throw new Error("Invalid recipient or amount");
            if (this.blockchain.getBalance() < amount) throw new Error("Insufficient funds");
            const tx = await this.blockchain.createTransaction(recipient, amount);
            this.broadcast({ type: 'transaction', data: tx });
            this.updateStatus(`[SYS] Transaction sent: ${amount} KRY to ${recipient.slice(0, 8)}`);
            document.getElementById("recipient").value = "";
            document.getElementById("amount").value = "";
        } catch (e) {
            this.updateStatus(`[ERR] Send failed: ${e.message}`);
        }
    }

    async stakeFractal() {
        const amount = parseFloat(document.getElementById("stakeAmount").value) || 0;
        if (amount <= 0 || this.blockchain.getBalance() < amount) {
            this.updateStatus("[ERR] Invalid stake amount or insufficient funds");
            return;
        }
        const stakeTx = await this.blockchain.createFractalStakeTransaction(amount, this.blockchain.longestChain.stats.height);
        this.broadcast({ type: 'transaction', data: stakeTx });
        this.updateStatus(`[SYS] Staked ${amount} KRY`);
        document.getElementById("stakeAmount").value = "";
    }

    async thawFractal() {
        const tx = await this.blockchain.thawNextFractalChunk();
        if (tx) {
            this.broadcast({ type: 'transaction', data: tx });
            this.updateStatus(`[SYS] Thawed ${tx.outputs[0].amount} KRY`);
        } else {
            this.updateStatus("[SYS] No cases ready to thaw");
        }
    }

    showBurnDialog() {
        document.getElementById('burnDialog').style.display = 'block';
    }

    hideBurnDialog() {
        document.getElementById('burnDialog').style.display = 'none';
        document.getElementById('burnAmount').value = '';
    }

    async burnKRY() {
        const amount = parseFloat(document.getElementById("burnAmount").value) || 0;
        if (amount <= 0 || this.blockchain.getBalance() < amount) {
            this.updateStatus("[ERR] Invalid burn amount or insufficient funds");
            return;
        }
        const burnTx = await this.blockchain.createBurnTransaction(amount);
        this.broadcast({ type: 'transaction', data: burnTx });
        this.updateStatus(`[SYS] Burned ${amount} KRY`);
        this.hideBurnDialog();
    }

    async sendChatMessage() {
        const message = document.getElementById('chatInput').value.trim();
        if (!message) {
            this.updateStatus("[ERR] Empty message");
            return;
        }
        if (!this.connectedPeers.size) {
            this.updateStatus("[ERR] No peers connected");
            return;
        }
        const messageId = `${this.pubKey}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const chatData = {
            message,
            timestamp: Date.now(),
            pubKey: this.pubKey,
            messageId,
            color: document.getElementById('chatColor').value,
            username: document.getElementById('chatUsername').value || 'Anonymous'
        };
        this.broadcast({ type: 'chat', data: chatData });
        this.displayChatMessage(chatData, this.pubKey);
        document.getElementById('chatInput').value = '';
        this.updateStatus("[SYS] Chat message sent");
    }

    displayChatMessage(data, fromPubKey) {
        if (this.messageHistory.has(data.messageId)) return;
        this.messageHistory.add(data.messageId);
        const chatLog = document.getElementById('chatLog');
        const time = new Date(data.timestamp).toLocaleTimeString();
        const sender = data.username || (fromPubKey === this.pubKey ? 'You' : fromPubKey.slice(0, 8));
        const color = data.color || '#FFFFFF';
        chatLog.innerHTML += `<div>[${time}] <span class="sender" style="color: ${color}">${sender}</span>: ${data.message}</div>`;
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    updateStatus(message) {
        document.getElementById('status').textContent = message;
    }

    updatePubKeyDisplay() {
        document.getElementById("pubKeyDisplay").textContent = `Your Public Key: ${this.pubKey || "Not set"}`;
        document.getElementById("walletAddress").textContent = this.pubKey || "Not set";
        document.getElementById("mineWalletAddress").textContent = this.pubKey || "Not set";
    }
}

class Blockchain {
    constructor(wallet) {
        this.wallet = wallet;
        this.longestChain = { block: null, utxos: {}, fractalStakes: {}, stats: { height: 0, difficulty: 1 } };
        this.secondLongestChain = null;
        this.pendingTxs = [];
        this.processedTxHashes = new Set();
        this.MINING_BASE_RATE = 3.14159;
        this.FRACTAL_CHUNKS = 10;
        this.REWARD_BOOST_PER_CHUNK = 0.01; 
        this.BLOCK_TIME = 15000;
        this.consensusInterval = null;
        this.isMining = false;
    }

    async loadChain() {
        const longestData = await getItem('blockchain', `longest_${this.wallet.pubKey}`);
        if (longestData) {
            this.longestChain = JSON.parse(longestData);
        }
        const secondData = await getItem('blockchain', `second_${this.wallet.pubKey}`);
        if (secondData) {
            this.secondLongestChain = JSON.parse(secondData);
        }
        this.processedTxHashes = new Set(this.longestChain.block?.transactions.map(tx => tx.hash) || []);
        this.updateUI();
    }

    async saveState() {
        await setItem('blockchain', `longest_${this.wallet.pubKey}`, JSON.stringify(this.longestChain));
        if (this.secondLongestChain) {
            await setItem('blockchain', `second_${this.wallet.pubKey}`, JSON.stringify(this.secondLongestChain));
        }
    }

    getBalance() {
        return (this.longestChain.utxos[this.wallet.pubKey] || []).reduce((sum, utxo) => sum + utxo.amount, 0);
    }

    getFractalStake() {
        return (this.longestChain.fractalStakes[this.wallet.pubKey] || []).reduce((sum, chunk) => sum + (chunk.isLocked ? chunk.amount : 0), 0);
    }

    getMiningRate() {
        const chunks = this.longestChain.fractalStakes[this.wallet.pubKey] || [];
        const thawedCount = chunks.filter(chunk => !chunk.isLocked).length;
        return this.MINING_BASE_RATE * (1 + thawedCount * this.REWARD_BOOST_PER_CHUNK);
    }

    getFrozenKryoCases() {
        return (this.longestChain.fractalStakes[this.wallet.pubKey] || []).filter(chunk => chunk.isLocked).length;
    }

    getThawedKryoCases() {
        return (this.longestChain.fractalStakes[this.wallet.pubKey] || []).filter(chunk => !chunk.isLocked).length;
    }

    getThawableKryoCases() {
        return (this.longestChain.fractalStakes[this.wallet.pubKey] || []).filter(chunk => chunk.isLocked && this.longestChain.stats.height >= chunk.lockHeight).length;
    }

    initializeWallet() {
        this.longestChain = {
            block: null,
            utxos: { [this.wallet.pubKey]: [] },
            fractalStakes: { [this.wallet.pubKey]: [] },
            stats: { height: 0, difficulty: 1 }
        };
        this.secondLongestChain = null;
        this.saveState();
    }

    async createTransaction(recipient, amount) {
        const inputs = [];
        let inputSum = 0;
        const availableUtxos = [...(this.longestChain.utxos[this.wallet.pubKey] || [])];
        for (const utxo of availableUtxos) {
            if (inputSum >= amount) break;
            inputs.push({ to: this.wallet.pubKey, txid: utxo.txid, vout: utxo.vout, amount: utxo.amount });
            inputSum += utxo.amount;
        }
        if (inputSum < amount) throw new Error("Insufficient funds");
        const tx = {
            inputs,
            outputs: [
                { to: recipient, amount },
                ...(inputSum > amount ? [{ to: this.wallet.pubKey, amount: inputSum - amount }] : [])
            ],
            fee: 0,
            timestamp: Date.now(),
            pubKey: this.wallet.pubKey,
            type: 'transfer'
        };
        tx.hash = await this.wallet.sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, fee: tx.fee, timestamp: tx.timestamp, type: tx.type }));
        tx.signature = this.wallet.keyPair.sign(tx.hash).toDER('hex');
        this.pendingTxs.push(tx);
        return tx;
    }

    async createFractalStakeTransaction(amount, currentHeight) {
        const inputs = [];
        let inputSum = 0;
        const availableUtxos = [...(this.longestChain.utxos[this.wallet.pubKey] || [])];
        for (const utxo of availableUtxos) {
            if (inputSum >= amount) break;
            inputs.push({ to: this.wallet.pubKey, txid: utxo.txid, vout: utxo.vout, amount: utxo.amount });
            inputSum += utxo.amount;
        }
        if (inputSum < amount) throw new Error("Insufficient funds");
        const chunkAmount = amount / this.FRACTAL_CHUNKS;
        const tx = {
            inputs,
            outputs: Array.from({ length: this.FRACTAL_CHUNKS }, (_, i) => ({
                to: this.wallet.pubKey,
                amount: chunkAmount,
                isFractal: true,
                lockHeight: currentHeight + 100 * (i + 1)
            })),
            fee: 0,
            timestamp: Date.now(),
            pubKey: this.wallet.pubKey,
            type: 'fractal_stake'
        };
        tx.hash = await this.wallet.sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, fee: tx.fee, timestamp: tx.timestamp, type: tx.type }));
        tx.signature = this.wallet.keyPair.sign(tx.hash).toDER('hex');
        this.pendingTxs.push(tx);
        return tx;
    }

    async createBurnTransaction(amount) {
        const inputs = [];
        let inputSum = 0;
        const availableUtxos = [...(this.longestChain.utxos[this.wallet.pubKey] || [])];
        for (const utxo of availableUtxos) {
            if (inputSum >= amount) break;
            inputs.push({ to: this.wallet.pubKey, txid: utxo.txid, vout: utxo.vout, amount: utxo.amount });
            inputSum += utxo.amount;
        }
        if (inputSum < amount) throw new Error("Insufficient funds");
        const tx = {
            inputs,
            outputs: [],
            fee: 0,
            timestamp: Date.now(),
            pubKey: this.wallet.pubKey,
            type: 'burn',
            burnAmount: amount
        };
        tx.hash = await this.wallet.sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, fee: tx.fee, timestamp: tx.timestamp, type: tx.type, burnAmount: tx.burnAmount }));
        tx.signature = this.wallet.keyPair.sign(tx.hash).toDER('hex');
        this.pendingTxs.push(tx);
        return tx;
    }

    async thawNextFractalChunk() {
        const chunks = this.longestChain.fractalStakes[this.wallet.pubKey] || [];
        const nextChunk = chunks.find(chunk => chunk.isLocked && this.longestChain.stats.height >= chunk.lockHeight);
        if (!nextChunk) return null;
        const tx = {
            inputs: [],
            outputs: [{ to: this.wallet.pubKey, amount: nextChunk.amount }],
            fee: 0,
            timestamp: Date.now(),
            pubKey: this.wallet.pubKey,
            type: 'fractal_unstake'
        };
        tx.hash = await this.wallet.sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, fee: tx.fee, timestamp: tx.timestamp, type: tx.type }));
        tx.signature = this.wallet.keyPair.sign(tx.hash).toDER('hex');
        this.pendingTxs.push(tx);
        nextChunk.isLocked = false;
        this.saveState();
        return tx;
    }

    async receiveTransaction(tx) {
        if (this.verifyTransaction(tx) && !this.processedTxHashes.has(tx.hash)) {
            this.pendingTxs.push(tx);
            await this.processPendingTxs();
            this.wallet.updateStatus(`[SYS] Processed transaction ${tx.hash.slice(0, 8)}`);
        }
    }

    verifyTransaction(tx) {
        const key = this.wallet.ec.keyFromPublic(tx.pubKey, 'hex');
        const msgHash = tx.hash || this.wallet.sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, fee: tx.fee, timestamp: tx.timestamp, type: tx.type, ...(tx.burnAmount ? { burnAmount: tx.burnAmount } : {}) }));
        return key.verify(msgHash, tx.signature);
    }

    async processPendingTxs() {
        for (const tx of [...this.pendingTxs]) {
            if (this.processedTxHashes.has(tx.hash)) {
                this.pendingTxs = this.pendingTxs.filter(t => t.hash !== tx.hash);
                continue;
            }
            const inputSum = tx.inputs.length ? tx.inputs.reduce((sum, input) => sum + input.amount, 0) : 0;
            const outputSum = tx.outputs.reduce((sum, out) => sum + out.amount, 0);
            if (tx.type !== 'burn' && tx.type !== 'fractal_unstake' && inputSum < outputSum) continue;
            if (tx.type === 'transfer' || tx.type === 'fractal_stake' || tx.type === 'burn') {
                tx.inputs.forEach(input => {
                    this.longestChain.utxos[input.to] = (this.longestChain.utxos[input.to] || []).filter(u => u.txid !== input.txid || u.vout !== input.vout);
                });
            }
            if (tx.type === 'fractal_stake') {
                const fractalOutputs = tx.outputs.filter(out => out.isFractal);
                this.longestChain.fractalStakes[tx.pubKey] = this.longestChain.fractalStakes[tx.pubKey] || [];
                fractalOutputs.forEach(out => {
                    this.longestChain.fractalStakes[tx.pubKey].push({
                        amount: out.amount,
                        lockHeight: out.lockHeight,
                        isLocked: true
                    });
                });
            }
            if (tx.type !== 'burn') {
                tx.outputs.forEach((out, i) => {
                    if (!out.isFractal) {
                        this.longestChain.utxos[out.to] = this.longestChain.utxos[out.to] || [];
                        this.longestChain.utxos[out.to].push({ txid: tx.hash, vout: i, amount: out.amount });
                    }
                });
            }
            this.processedTxHashes.add(tx.hash);
            this.pendingTxs = this.pendingTxs.filter(t => t.hash !== tx.hash);
        }
        this.saveState();
        this.updateUI();
    }

    startMining() {
        if (!this.wallet.pubKey) {
            this.wallet.updateStatus("[ERR] No wallet loaded. Please login or create a wallet.");
            return;
        }
        if (!this.isMining) {
            this.isMining = true;
            this.consensusInterval = setInterval(async () => {
                await this.mineBlock();
            }, this.BLOCK_TIME);
            this.wallet.updateStatus("[SYS] Mining started");
        }
    }

    async mineBlock() {
        if (!this.isMining) return;

        await this.syncWithPeers();

        const block = {
            timestamp: Date.now(),
            rewards: { [this.wallet.pubKey]: this.getMiningRate() },
            transactions: [],
            previousHash: this.longestChain.block ? await this.wallet.sha256(JSON.stringify(this.longestChain.block)) : "0",
            height: this.longestChain.stats.height + 1
        };
        await this.processPendingTxs();
        block.transactions = [...this.pendingTxs];
        block.hash = await this.wallet.sha256(JSON.stringify({
            timestamp: block.timestamp,
            rewards: block.rewards,
            transactions: block.transactions,
            previousHash: block.previousHash,
            height: block.height
        }));
        if (await this.verifyBlock(block)) {
            if (this.longestChain.block) {
                this.secondLongestChain = { ...this.longestChain };
            }
            this.longestChain.block = block;
            this.longestChain.stats.height = block.height;
            for (const [pubKey, reward] of Object.entries(block.rewards)) {
                this.longestChain.utxos[pubKey] = this.longestChain.utxos[pubKey] || [];
                this.longestChain.utxos[pubKey].push({ txid: block.hash, vout: 0, amount: reward });
            }
            this.processedTxHashes = new Set(block.transactions.map(tx => tx.hash));
            this.pendingTxs = [];
            this.saveState();
            this.appendToLog(`Block ${block.hash.slice(0, 8)} - Height: ${block.height}`);
            this.updateUI();
            this.wallet.broadcast({ type: 'block', data: block });
            this.wallet.updateStatus(`[SYS] Mined block at height ${block.height}`);
        } else {
            this.wallet.updateStatus("[ERR] Failed to verify mined block");
        }
    }

    async receiveBlock(block, fromPeerPubkey) {
        if (this.longestChain.block?.hash === block.hash) return;
        if (block.height > this.longestChain.stats.height) {
            if (await this.verifyBlock(block)) {
                this.secondLongestChain = { ...this.longestChain };
                this.longestChain.block = block;
                this.longestChain.stats.height = block.height;
                this.updateStateFromBlock(block);
                this.saveState();
                this.wallet.updateStatus(`[SYS] New longest chain at height ${block.height} from ${fromPeerPubkey.slice(0, 8)}`);
                this.updateUI();
            }
        } else if (block.height === this.longestChain.stats.height - 1 && !this.secondLongestChain) {
            this.secondLongestChain = {
                block,
                utxos: { ...this.longestChain.utxos },
                fractalStakes: { ...this.longestChain.fractalStakes },
                stats: { height: block.height, difficulty: 1 }
            };
            this.saveState();
        }
    }

    async verifyBlock(block) {
        const expectedHash = await this.wallet.sha256(JSON.stringify({
            timestamp: block.timestamp,
            rewards: block.rewards,
            transactions: block.transactions,
            previousHash: block.previousHash,
            height: block.height
        }));
        return expectedHash === block.hash;
    }

    updateStateFromBlock(block) {
        for (const [pubKey, reward] of Object.entries(block.rewards)) {
            this.longestChain.utxos[pubKey] = this.longestChain.utxos[pubKey] || [];
            this.longestChain.utxos[pubKey].push({ txid: block.hash, vout: 0, amount: reward });
        }
        this.processedTxHashes = new Set(block.transactions.map(tx => tx.hash));
        this.processPendingTxs();
    }

    async syncWithPeers() {
        if (this.wallet.connectedPeers.size === 0) {
            this.wallet.updateStatus("[SYS] No peers connected, using local chain");
            return;
        }
        Object.values(this.wallet.peers).forEach(({ channel }) => {
            if (channel?.readyState === 'open') {
                channel.send(JSON.stringify({ type: 'state_request', pubKey: this.wallet.pubKey }));
            }
        });
    }

    requestStateSync(channel) {
        if (channel.readyState === 'open') {
            channel.send(JSON.stringify({ type: 'state_request', pubKey: this.wallet.pubKey }));
        }
    }

    async syncState(state) {
        if (state.stats.height > this.longestChain.stats.height) {
            this.secondLongestChain = { ...this.longestChain };
            this.longestChain = {
                block: state.chain[state.chain.length - 1],
                utxos: state.utxos,
                fractalStakes: state.fractalStakes,
                stats: state.stats
            };
            this.processedTxHashes = new Set(this.longestChain.block.transactions.map(tx => tx.hash));
            this.saveState();
            this.updateUI();
            this.wallet.updateStatus(`[SYS] Synced to height ${this.longestChain.stats.height}`);
        }
    }

    appendToLog(message) {
        const log = document.getElementById(this.wallet.currentScreen === 'mine' ? 'mineLog' : this.wallet.currentScreen === 'staking' ? 'stakeLog' : 'log');
        log.innerHTML += `<div>${message}</div>`;
        log.scrollTop = log.scrollHeight;
    }

    updateUI() {
        const balance = this.getBalance().toFixed(5);
        const fractalStake = this.getFractalStake().toFixed(5);
        const miningRate = this.getMiningRate().toFixed(5);
        const peerCount = this.wallet.connectedPeers.size;
        const height = this.longestChain.stats.height;
        const frozenCases = this.getFrozenKryoCases();
        const thawedCases = this.getThawedKryoCases();
        const thawableCases = this.getThawableKryoCases();

        document.getElementById('hudBalance').textContent = balance;
        document.getElementById('hudFractalStake').textContent = fractalStake;
        document.getElementById('hudMiningRate').textContent = `${miningRate} KRY/block`;
        document.getElementById('hudHeight').textContent = height;
        document.getElementById('hudPeerCount').textContent = peerCount;

        document.getElementById('stakeDetails').textContent = `KryoCases Frozen: ${frozenCases} | Unfroze: ${thawedCases}`;
        const thawBtn = document.getElementById('thawBtn');
        thawBtn.textContent = `Thaw (${thawableCases})`;
        thawBtn.disabled = thawableCases === 0;
    }
}

const wallet = new CryptoWallet();

</script></body>
</html>

